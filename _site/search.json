[
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#getting-started",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#getting-started",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nAs usual, to get started, we will load the necessary R packages. For the purpose of this in-class exercise, multiple R packages will be used, they are:\n\n\nSpatial data handling\n\nsf, rgdal and spdep\n\nAttribute data handling\n\ntidyverse, especially readr, ggplot2 and dplyr\n\nChoropleth mapping\n\ntmap\n\nMultivariate data visualisation and analysis\n\ncoorplot, ggpubr, GGAlly, and heatmaply\n\nCluster analysis\n\ncluster\nClustGeo\nNbClust\n\n\n\n\npacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally,funModeling)\n\n\n#command above make sure quarto does not execute\nwp <- st_read(dsn = \"geodata\",\n        layer = \"geo_export\",\n        crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\n\nwp_sf <- st_sf(wp, crs=4326) \n\n\nnga <- st_read(dsn = \"geodata\",\n              layer = \"geoboundaries-NGA-ADM2\")"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#data-wrangling",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#data-wrangling",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nHandling Duplicates\nBelow codes are referenced from our exemplary classmate Jordan (link), recommended by prof Kam.\n\nnigeria <- (nga[order(nga$shapeName), ])\n\nduplicate_area <- nigeria$shapeName[ nigeria$shapeName %in% nigeria$shapeName[duplicated(nigeria$shapeName)] ]\n\nduplicate_area\n\n\ntmap_mode(\"view\")\n\ntm_shape(nigeria[nigeria$shapeName %in% duplicate_area,]) +\n  tm_view(set.zoom.limits = c(5,9))+\n  tm_polygons()\n\n\nnigeria$shapeName[c(94,95,304,305,355,356,519,546,547,693,694)] <- c(\"Bassa (Kogi)\",\"Bassa (Plateau)\",\n                                                                               \"Ifelodun (Kwara)\",\"Ifelodun (Osun)\",\n                                                                               \"Irepodun (Kwara)\",\"Irepodun (Osun)\",\n                                                                               \"Nassarawa\",\"Obi (Benue)\",\"Obi(Nasarawa)\",\n                                                                               \"Surulere (Lagos)\",\"Surulere (Oyo)\")\n\nlength((nigeria$shapeName[ nigeria$shapeName %in% nigeria$shapeName[duplicated(nigeria$shapeName)] ]))\n\nHere we replaced NA values with “Unknown” to help facilitate processing\n\nwp_sf <- st_join(wp_sf, nigeria)  %>%\n  mutate(status_cle=replace_na(status_cle,\"Unknown\"))"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#exploratory-data-analysis",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#exploratory-data-analysis",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Exploratory Data Analysis",
    "text": "Exploratory Data Analysis\nFirst we look at the distribution of waterpoints based on their operational status\n\nfreq(data=wp_sf,\n     input = 'status_cle')"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "",
    "text": "wpt_functional <- wp_sf %>%\n  filter(status_cle %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\nwpt_nonfunctional <- wp_sf %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\nHere we can see that hand pumps are a overwhelming potential for the type of water point so we will carry on using hand pump waterpoints as a variable.\n\nfreq(data=wp_sf, \n     input = 'water_te_2')\n\nAs there are some Hand Pumps that are labelled slightly differently, we have to use str_detect from stringr library to do a wildcard detection where we filter for anything that contains “Hand Pump”\n\nwpt_handpump <- wp_sf %>%\n  filter(str_detect(water_te_2, \"Hand Pump\"))\n\n\nfreq(data=wpt_handpump, \n     input = 'water_te_2')\n\nHere we can see the general distribution is that the usage cap or limit is 1000 or below 1000.\n\nfreq(data=wp_sf, \n     input = 'usage_cap')\n\nNext we divide them and take a look if our previous split is correct\n\nwpt_usage_abv_1000 <- wp_sf %>%\n  filter(`usage_cap` >= 1000)\n\n\nwpt_usage_less_1000 <- wp_sf %>%\n  filter(`usage_cap` < 1000)\n\n\nfreq(data=wpt_usage_less_1000, \n     input = 'usage_cap')\n\nThen we take a look at how much of the area is considered rural (is_urban = False)\n\nfreq(data=wp_sf, \n     input = 'is_urban')\n\n\nwpt_rural <- wp_sf %>%\n  filter(`is_urban` == \"False\")\n\n\nfreq(data=wpt_rural, \n     input = 'is_urban')\n\nFor this part, we get the number of water points and their respective figures in each LGA by using the mutate function along with lengths and st_intercepts\n\nnga_wp <- nigeria %>% \n  mutate(`total wpt` = lengths(\n    st_intersects( nigeria,wp_sf))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nigeria, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nigeria, wpt_nonfunctional))) %>%\n  mutate(`wpt_handpump` = lengths(\n    st_intersects(nigeria, wpt_handpump))) %>%\n  mutate(`wpt usage_cap 1000` = lengths(\n    st_intersects(nigeria, wpt_usage_abv_1000))) %>%\n  mutate(`wpt usage_cap below 1000` = lengths(\n    st_intersects(nigeria, wpt_usage_less_1000))) %>%\n  mutate(`wpt rural` = lengths(\n    st_intersects(nigeria, wpt_rural)))\n\nThis file is then saved:\n\nwrite_rds(nga_wp, \"geodata/nga_wp.rds\")\n\nHere we read in the saved file while also removing the na fields for functional and non functional water points\n\nnga_wp <- read_rds(\"geodata/nga_wp.rds\")\nnga_wp <- nga_wp %>%\n  filter(`total wpt` > 0) %>%\n  mutate(`wpt non-functional` = replace_na(`wpt non-functional`, 0)) %>%\n  mutate(`wpt functional` = replace_na(`wpt functional`, 0))\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nnga_wp <- st_transform(nga_wp, \n                              crs = 26391)\ntotal <- tm_shape(nga_wp) +\n  tm_fill(\"total wpt\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"total\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nwp_functional <- tm_shape(nga_wp) +\n  tm_fill(\"wpt functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nwp_nonfunctional <- tm_shape(nga_wp) +\n  tm_fill(\"wpt non-functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"non-functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nhandpump <- tm_shape(nga_wp) +\n  tm_fill(\"wpt_handpump\",\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"handpump\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nusageabv <- tm_shape(nga_wp) +\n  tm_fill(\"wpt usage_cap 1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"usage cap 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nusagebelow <- tm_shape(nga_wp) +\n  tm_fill(\"wpt usage_cap below 1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"usage cap < 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nrural <- tm_shape(nga_wp) +\n  tm_fill(\"wpt rural\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"rural waterpoints\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\n\ntmap_arrange(total, wp_functional, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(wp_nonfunctional, handpump, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(usageabv,usagebelow, asp=1, ncol=2)\n\n\n\n\nWe can see from below if total water points and rural water points are used for comparison, they look about the same, therefore it could be better to look at the percentage\n\ntmap_arrange(total,rural,asp=1, ncol=2)\n\n\n\n\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = case_when(\n    `wpt functional` == 0 ~ 0,\n    TRUE ~ `wpt functional`/`total wpt`\n    )) %>%\n  mutate(pct_nonfunctional = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt non-functional`/`total wpt`\n    )) %>%\n  mutate(pct_handpump = case_when(\n    `wpt_handpump` == 0 ~ 0,\n    TRUE ~ `wpt_handpump`/`total wpt`\n    )) %>%\n  mutate(pct_rural = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt rural`/`total wpt`\n    )) %>%\n  mutate(pct_usage1000 = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt usage_cap 1000`/`total wpt`\n    )) %>%\n  mutate(pct_usage_below_1000 = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt usage_cap below 1000`/`total wpt`\n    )) \n\n\npct_functional <- tm_shape(nga_wp) +\n  tm_fill(\"pct_functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_nonfunctional <- tm_shape(nga_wp) +\n  tm_fill(\"pct_nonfunctional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"non-functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_handpump <- tm_shape(nga_wp) +\n  tm_fill(\"pct_handpump\",\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of handpumps\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_usageabv <- tm_shape(nga_wp) +\n  tm_fill(\"pct_usage1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoints usage = 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_usagebelow <- tm_shape(nga_wp) +\n  tm_fill(\"pct_usage_below_1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoints usage below 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_rural <- tm_shape(nga_wp) +\n  tm_fill(\"pct_rural\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoint that are rural\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\n\ntmap_arrange(pct_functional, pct_nonfunctional, pct_handpump,pct_usageabv,pct_usagebelow, pct_rural, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(pct_functional, pct_nonfunctional, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(pct_usageabv,pct_usagebelow, asp=1, ncol=2)\n\n\n\n\nPercentage for rural water points and total paints a different picture compared to the absolute number of rural water points seen above\n\ntmap_arrange(total, pct_rural, asp=1, ncol=2)\n\n\n\n\n\nSummary Statistics\n\nsummary(nga_wp)\n\n  shapeName            Level             shapeID           shapeGroup       \n Length:761         Length:761         Length:761         Length:761        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n  shapeType                  geometry     total wpt     wpt functional  \n Length:761         MULTIPOLYGON :761   Min.   :  1.0   Min.   :  0.00  \n Class :character   epsg:26391   :  0   1st Qu.: 48.0   1st Qu.: 18.00  \n Mode  :character   +proj=tmer...:  0   Median : 97.0   Median : 47.00  \n                                        Mean   :124.8   Mean   : 68.51  \n                                        3rd Qu.:170.0   3rd Qu.: 88.00  \n                                        Max.   :894.0   Max.   :752.00  \n wpt non-functional  wpt_handpump    wpt usage_cap 1000\n Min.   :  0.00     Min.   :  0.00   Min.   :  0.00    \n 1st Qu.: 14.00     1st Qu.:  7.00   1st Qu.: 12.00    \n Median : 34.00     Median : 48.00   Median : 26.00    \n Mean   : 42.31     Mean   : 77.18   Mean   : 33.69    \n 3rd Qu.: 61.00     3rd Qu.:112.00   3rd Qu.: 46.00    \n Max.   :278.00     Max.   :764.00   Max.   :245.00    \n wpt usage_cap below 1000   wpt rural      pct_functional   pct_nonfunctional\n Min.   :  0.00           Min.   :  0.00   Min.   :0.0000   Min.   :0.0000   \n 1st Qu.: 18.00           1st Qu.: 25.00   1st Qu.:0.3333   1st Qu.:0.2211   \n Median : 61.00           Median : 65.00   Median :0.4792   Median :0.3559   \n Mean   : 91.12           Mean   : 99.11   Mean   :0.5070   Mean   :0.3654   \n 3rd Qu.:129.00           3rd Qu.:143.00   3rd Qu.:0.6749   3rd Qu.:0.5082   \n Max.   :767.00           Max.   :894.00   Max.   :1.0000   Max.   :1.0000   \n  pct_handpump      pct_rural      pct_usage1000    pct_usage_below_1000\n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000      \n 1st Qu.:0.1860   1st Qu.:0.5702   1st Qu.:0.1197   1st Qu.:0.3814      \n Median :0.5255   Median :0.8642   Median :0.3060   Median :0.6630      \n Mean   :0.4956   Mean   :0.7224   Mean   :0.3683   Mean   :0.5989      \n 3rd Qu.:0.7857   3rd Qu.:1.0000   3rd Qu.:0.5667   3rd Qu.:0.8676      \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000      \n\n\n\nfunc <- ggplot(data=nga_wp, \n             aes(x= `wpt functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nnonfunc <- ggplot(data=nga_wp, \n             aes(x= `wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nggarrange(func , nonfunc,\n          ncol = 2, \n          nrow = 1)\n\n\n\n\n\nfunc <- ggplot(data=nga_wp, \n             aes(x= `pct_functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nnonfunc <- ggplot(data=nga_wp, \n             aes(x= `pct_nonfunctional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nhandp <- ggplot(data=nga_wp, \n             aes(x= `pct_handpump`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nusagehigh <- ggplot(data=nga_wp, \n             aes(x= `pct_usage1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nusagelow <- ggplot(data=nga_wp, \n             aes(x= `pct_usage_below_1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nrural <- ggplot(data=nga_wp, \n             aes(x= `pct_rural`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\n\nggarrange(func , nonfunc, handp , usagehigh, usagelow, rural, ncol = 3,nrow = 2)\n\n\n\n\n\n\nCorrelation analysis\nSet geometry column to null for correlation analysis\n\nnga_wp$\"wpt functional\" <- as.numeric(nga_wp$\"wpt functional\")\nnga_wp$\"wpt non-functional\" <- as.numeric(nga_wp$\"wpt non-functional\")\nnga_wp_nogeo <- nga_wp %>%\n  st_set_geometry(NULL) %>%\n  select(\"shapeName\", \"wpt non-functional\", \"wpt functional\", \"pct_functional\",\"pct_nonfunctional\", \"pct_handpump\", \"pct_usage_below_1000\",\"pct_usage1000\", \"pct_rural\")\nhead(nga_wp_nogeo,10)\n\n        shapeName wpt non-functional wpt functional pct_functional\n1       Aba North                  9              7      0.4117647\n2       Aba South                 35             29      0.4084507\n3           Abaji                 34             23      0.4035088\n4            Abak                 25             23      0.4791667\n5       Abakaliki                 42             82      0.3519313\n6  Abeokuta North                 15             16      0.4705882\n7  Abeokuta South                 33             72      0.6050420\n8             Abi                 62             79      0.5197368\n9     Aboh-Mbaise                 26             18      0.2727273\n10     Abua/Odual                 13             25      0.6410256\n   pct_nonfunctional pct_handpump pct_usage_below_1000 pct_usage1000  pct_rural\n1          0.5294118   0.11764706           0.17647059     0.8235294 0.00000000\n2          0.4929577   0.09859155           0.12676056     0.8732394 0.05633803\n3          0.5964912   0.40350877           0.40350877     0.5964912 0.84210526\n4          0.5208333   0.08333333           0.08333333     0.9166667 0.83333333\n5          0.1802575   0.43776824           0.90557940     0.0944206 0.87553648\n6          0.4411765   0.14705882           0.23529412     0.7647059 0.20588235\n7          0.2773109   0.16806723           0.29411765     0.7058824 0.00000000\n8          0.4078947   0.59868421           0.67105263     0.3289474 0.95394737\n9          0.3939394   0.01515152           0.34848485     0.6515152 0.72727273\n10         0.3333333   0.30769231           0.33333333     0.6666667 0.53846154\n\n\n\ncluster_vars.cor = cor(nga_wp_nogeo[,2:9])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",,number.cex=0.5,\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nWe can see from the correlation plot here that the usage percentage above 1000 and below 1000 are highly correlated, that is probably because if the usage is not >=1000, then it will belong in the other category. This likely means that only one should be used for cluster analysis, in this case we will be dropping percentage of water point with usage >=1000 and using the one that is below 1000."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#hierarchy-cluster-analysis",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#hierarchy-cluster-analysis",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Hierarchy Cluster Analysis",
    "text": "Hierarchy Cluster Analysis\n\nExtracting clustering variables\n\ncluster_vars <- nga_wp_nogeo %>%\n  select(\"shapeName\", \"wpt non-functional\", \"wpt functional\", \"pct_functional\",\"pct_nonfunctional\", \"pct_handpump\", \"pct_usage_below_1000\", \"pct_rural\")\nhead(cluster_vars,10)\n\n        shapeName wpt non-functional wpt functional pct_functional\n1       Aba North                  9              7      0.4117647\n2       Aba South                 35             29      0.4084507\n3           Abaji                 34             23      0.4035088\n4            Abak                 25             23      0.4791667\n5       Abakaliki                 42             82      0.3519313\n6  Abeokuta North                 15             16      0.4705882\n7  Abeokuta South                 33             72      0.6050420\n8             Abi                 62             79      0.5197368\n9     Aboh-Mbaise                 26             18      0.2727273\n10     Abua/Odual                 13             25      0.6410256\n   pct_nonfunctional pct_handpump pct_usage_below_1000  pct_rural\n1          0.5294118   0.11764706           0.17647059 0.00000000\n2          0.4929577   0.09859155           0.12676056 0.05633803\n3          0.5964912   0.40350877           0.40350877 0.84210526\n4          0.5208333   0.08333333           0.08333333 0.83333333\n5          0.1802575   0.43776824           0.90557940 0.87553648\n6          0.4411765   0.14705882           0.23529412 0.20588235\n7          0.2773109   0.16806723           0.29411765 0.00000000\n8          0.4078947   0.59868421           0.67105263 0.95394737\n9          0.3939394   0.01515152           0.34848485 0.72727273\n10         0.3333333   0.30769231           0.33333333 0.53846154\n\n\nIn the code below, we first change the row name to be same as “shapeName” which is the area name and then we remove the column\n\nrow.names(cluster_vars) <- cluster_vars$\"shapeName\"\nnga_wp_analysis <- select(cluster_vars, c(2:8))\nhead(nga_wp_analysis, 10)\n\n               wpt non-functional wpt functional pct_functional\nAba North                       9              7      0.4117647\nAba South                      35             29      0.4084507\nAbaji                          34             23      0.4035088\nAbak                           25             23      0.4791667\nAbakaliki                      42             82      0.3519313\nAbeokuta North                 15             16      0.4705882\nAbeokuta South                 33             72      0.6050420\nAbi                            62             79      0.5197368\nAboh-Mbaise                    26             18      0.2727273\nAbua/Odual                     13             25      0.6410256\n               pct_nonfunctional pct_handpump pct_usage_below_1000  pct_rural\nAba North              0.5294118   0.11764706           0.17647059 0.00000000\nAba South              0.4929577   0.09859155           0.12676056 0.05633803\nAbaji                  0.5964912   0.40350877           0.40350877 0.84210526\nAbak                   0.5208333   0.08333333           0.08333333 0.83333333\nAbakaliki              0.1802575   0.43776824           0.90557940 0.87553648\nAbeokuta North         0.4411765   0.14705882           0.23529412 0.20588235\nAbeokuta South         0.2773109   0.16806723           0.29411765 0.00000000\nAbi                    0.4078947   0.59868421           0.67105263 0.95394737\nAboh-Mbaise            0.3939394   0.01515152           0.34848485 0.72727273\nAbua/Odual             0.3333333   0.30769231           0.33333333 0.53846154\n\n\n\n\nData Standardisation\nSince, we can see from above, the number of functional and non-functional water points are not standardised, we would need to perform data standardisation for these 2 columns. They are also not normally distributed so we will be performing min-max standardisation here as we want our data to be still in the same scale as those in percentage.\n\nnga_wp_analysis.std <- nga_wp_analysis %>%\n  normalize(nga_wp_analysis[,1:2])\n#left_join(nga_wp_analysis.std,nga_wp_analysis[,3:7], by = \"row\")\nsummary(nga_wp_analysis.std)\n\n wpt non-functional wpt functional    pct_functional   pct_nonfunctional\n Min.   :0.00000    Min.   :0.00000   Min.   :0.0000   Min.   :0.0000   \n 1st Qu.:0.05036    1st Qu.:0.02394   1st Qu.:0.3333   1st Qu.:0.2211   \n Median :0.12230    Median :0.06250   Median :0.4792   Median :0.3559   \n Mean   :0.15218    Mean   :0.09110   Mean   :0.5070   Mean   :0.3654   \n 3rd Qu.:0.21942    3rd Qu.:0.11702   3rd Qu.:0.6749   3rd Qu.:0.5082   \n Max.   :1.00000    Max.   :1.00000   Max.   :1.0000   Max.   :1.0000   \n  pct_handpump    pct_usage_below_1000   pct_rural     \n Min.   :0.0000   Min.   :0.0000       Min.   :0.0000  \n 1st Qu.:0.1860   1st Qu.:0.3814       1st Qu.:0.5702  \n Median :0.5255   Median :0.6630       Median :0.8642  \n Mean   :0.4956   Mean   :0.5989       Mean   :0.7224  \n 3rd Qu.:0.7857   3rd Qu.:0.8676       3rd Qu.:1.0000  \n Max.   :1.0000   Max.   :1.0000       Max.   :1.0000  \n\n\n\n\nVisualising the standardised clustering variables\nWe can see from the distribution below for the right plot that the non-functional water points field has been normalised to values between 0 and 1(without change in distribution) instead of the non-standardised values in the plot on the left.\n\nr <- ggplot(data=nga_wp_analysis, \n             aes(x= `wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nanalysis_df <- as.data.frame(nga_wp_analysis.std)\ns <- ggplot(data=analysis_df, \n       aes(x=`wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nggarrange(r, s,\n          ncol =2,\n          nrow = 1)\n\n\n\n\n\n\nComputing proximity matrix\nConsidering we are measuring geometric distance and based on grids, euclidean distance is chosen as the method.\n\nproxmat <- dist(nga_wp_analysis.std, method = 'euclidean')\n\n\n\nComputing hierarchical clustering\n\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\n\nplot(hclust_ward, cex = 0.6)\n\n\n\n\n\n\nSelecting the optimal clustering algorithm\nFor hierarchical clustering, there are various ways to sequence the clustering. Due to that, it can sometimes be hard to pick which is the better option for the given dataset. Therefore in order to pick out the most suitable clustering technique, we use the agnes() function of cluster package. This function will help pick out the best clustering structure based on the agglomerative coefficent where 1 would be the best score.\n\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(nga_wp_analysis.std, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n  average    single  complete      ward \n0.9054253 0.7677768 0.9415830 0.9910247 \n\n\nAs we see above, ward’s method presents the best clustering structure with a score of 0.99. Therefore, we would proceed with ward’s method for subsequent analysis.\n\n\nDetermining Optimal Clusters\nDetermining the number of optimal cluster is also another difficult challenge in the realm of clustering. For this, we’ll be using the gap statistic method, which is sort of similar to elbow method for choosing the optimal number of clusters. To compute the gap statistic, clusGap() of cluster package will be used. We specify max number of clusters to be 10, and number of monte carlo sampling to be 500 as recommended by the documentation.\n\nset.seed(12345)\ngap_stat <- clusGap(nga_wp_analysis.std, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 500)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = nga_wp_analysis.std, FUNcluster = hcut, K.max = 10, B = 500, nstart = 25)\nB=500 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 10\n          logW   E.logW       gap      SE.sim\n [1,] 5.096626 5.638929 0.5423031 0.007110390\n [2,] 4.873943 5.534293 0.6603497 0.009545438\n [3,] 4.756242 5.481609 0.7253662 0.008869419\n [4,] 4.666234 5.437195 0.7709611 0.009345141\n [5,] 4.612874 5.404208 0.7913343 0.008704832\n [6,] 4.559968 5.376020 0.8160519 0.008668227\n [7,] 4.521663 5.351141 0.8294784 0.008701038\n [8,] 4.495129 5.329140 0.8340112 0.008588832\n [9,] 4.456500 5.309351 0.8528514 0.008341663\n[10,] 4.425849 5.291402 0.8655533 0.008149886\n\n\n\nfviz_gap_stat(gap_stat)\n\n\n\n\n\nprint(gap_stat, method = \"globalSEmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = nga_wp_analysis.std, FUNcluster = hcut, K.max = 10, B = 500, nstart = 25)\nB=500 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'globalSEmax', SE.factor=1): 10\n          logW   E.logW       gap      SE.sim\n [1,] 5.096626 5.638929 0.5423031 0.007110390\n [2,] 4.873943 5.534293 0.6603497 0.009545438\n [3,] 4.756242 5.481609 0.7253662 0.008869419\n [4,] 4.666234 5.437195 0.7709611 0.009345141\n [5,] 4.612874 5.404208 0.7913343 0.008704832\n [6,] 4.559968 5.376020 0.8160519 0.008668227\n [7,] 4.521663 5.351141 0.8294784 0.008701038\n [8,] 4.495129 5.329140 0.8340112 0.008588832\n [9,] 4.456500 5.309351 0.8528514 0.008341663\n[10,] 4.425849 5.291402 0.8655533 0.008149886\n\n\nBoth the firstmax and globalSEmax methods agree that the optimal number of clusters is 10, however it seems that the number is still going up and it is not that feasible to have that many clusters so we look at another methodology below:\n\n\nAverage Silhouette Method\nFor the average silthouette method, we can see that 6 cluster is the sweet spot where there is not too little custer and the average silhouette width is maximized and clusters have the least overlap\n\nset.seed(1234)\nfviz_nbclust(nga_wp_analysis.std, kmeans, method = \"silhouette\", k.max = 10) + theme_minimal() + ggtitle(\"Elbow cut method\")\n\n\n\n\n\n\nInterpreting the dendrograms\n\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n\n\n\n\n\n\nVisually-driven hierarchical clustering analysis\n\nTransforming the data frame into a matrix\nThe data was loaded into a data frame, but it has to be a data matrix to make your heatmap.\nThe code chunk below will be used to transform nga_wp_analysis.std(normalized) into a data matrix.\n\nnga_wp_analysis_mat <- data.matrix(nga_wp_analysis.std)\n\n\n\nPlotting interactive cluster heatmap using heatmaply()\nIn the code chunk below, the heatmaply() of heatmaply package is used to build an interactive cluster heatmap.\n\nheatmaply(nga_wp_analysis_mat,\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Nigeria by multi variate waterpoint attributes\",\n          xlab = \"Waterpoint attributes\",\n          ylab = \"Nigerian LGAs\"\n          )\n\n\n\n\n\n\n\n\nMapping the clusters formed\nWith closed examination of the dendragram above, we have decided to retain 6 clusters.\ncutree() of R Base will be used in the code chunk below to derive a 6-cluster model.\n\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\n\nnga_wp_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\n\nqtm(nga_wp_cluster, \"CLUSTER\")\n\n\n\n\nAs demonstrated in the map above, the clustering is rather fragmented and as hierarchical is not natively suited for geospatial clustering."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-skater-approach",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-skater-approach",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Spatially Constrained Clustering: SKATER approach",
    "text": "Spatially Constrained Clustering: SKATER approach\n\nConverting into SpatialPolygonsDataFrame\nAs SKATER only allows the use of sp objects(Spatial Polygon Dataframe), we have to convert the original dataframe.\n\nnga_wp_sp <- as_Spatial(nga_wp)\n\n\n\nComputing Neighbour List\n\nnga_wp.nb <- poly2nb(nga_wp_sp)\nsummary(nga_wp.nb)\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n136 497 513 547 with 1 link\n1 most connected region:\n496 with 14 links\n\n\n\nplot(nga_wp_sp, \n     border=grey(.5))\nplot(nga_wp.nb, \n     coordinates(nga_wp_sp), \n     col=\"blue\", \n     add=TRUE)\n\n\n\n\n\n\nComputing minimum spanning tree\n\nCalculating edge costs\nNext, nbcosts() of spdep package is used to compute the cost of each edge. This function compute this distance between each node using the data.frame with observations vector in each node.\n\nlcosts <- nbcosts(nga_wp.nb, nga_wp_analysis.std)\n\n\nnga_wp.w <- nb2listw(nga_wp.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(nga_wp.w)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n136 497 513 547 with 1 link\n1 most connected region:\n496 with 14 links\n\nWeights style: B \nWeights constants summary:\n    n     nn       S0       S1       S2\nB 761 579121 2276.992 3167.591 33929.71\n\n\n\n\n\nComputing minimum spanning tree\nThe minimum spanning tree is computed by mean of the mstree() of spdep package as shown in the code chunk below.\n\nnga_wp.mst <- mstree(nga_wp.w)\n\nCheck if MST is computed and converted to MST class propertly\n\nclass(nga_wp.mst )\n\n[1] \"mst\"    \"matrix\"\n\n\nwe can also see the dimensions of the MST\n\ndim(nga_wp.mst)\n\n[1] 760   3\n\n\n\nhead(nga_wp.mst)\n\n     [,1] [,2]      [,3]\n[1,]  615  614 0.2338982\n[2,]  614  709 0.1913884\n[3,]  709  595 0.2630492\n[4,]  595  197 0.2513327\n[5,]  197  306 0.1603990\n[6,]  197   56 0.2038302\n\n\n\nplot(nga_wp_sp, border=gray(.5))\nplot.mst(nga_wp.mst, \n         coordinates(nga_wp_sp), \n         col=\"blue\", \n         cex.lab=0.3, \n         cex.circles=0.005, \n         add=TRUE)\n\n\n\n\n\n\nComputing spatially constrained clusters using SKATER method\n\nclust6 <- spdep::skater(edges = nga_wp.mst[,1:2], \n                 data = nga_wp_analysis.std, \n                 method = \"euclidean\", \n                 ncuts = 5)\n\n\nstr(clust6)\n\nList of 8\n $ groups      : num [1:761] 2 2 1 2 6 1 1 6 2 1 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:141] 310 311 545 194 559 334 732 14 595 567 ...\n  .. ..$ edge: num [1:140, 1:3] 14 567 81 212 346 531 174 310 545 311 ...\n  .. ..$ ssw : num 76.3\n  ..$ :List of 3\n  .. ..$ node: num [1:128] 33 41 546 574 525 720 369 282 325 370 ...\n  .. ..$ edge: num [1:127, 1:3] 102 18 33 33 370 41 715 546 566 22 ...\n  .. ..$ ssw : num 67\n  ..$ :List of 3\n  .. ..$ node: num [1:238] 49 683 695 229 463 639 660 429 651 679 ...\n  .. ..$ edge: num [1:237, 1:3] 651 639 660 429 679 146 129 735 651 472 ...\n  .. ..$ ssw : num 111\n  ..$ :List of 3\n  .. ..$ node: num [1:122] 585 363 352 451 28 171 70 69 597 537 ...\n  .. ..$ edge: num [1:121, 1:3] 585 270 451 585 272 171 28 16 34 70 ...\n  .. ..$ ssw : num 53.8\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 113 144 265 432 89 469 382 465 158 497 ...\n  .. ..$ edge: num [1:10, 1:3] 265 265 113 432 89 465 158 469 144 382 ...\n  .. ..$ ssw : num 5.48\n  ..$ :List of 3\n  .. ..$ node: num [1:121] 668 408 235 161 711 461 413 131 722 727 ...\n  .. ..$ edge: num [1:120, 1:3] 458 408 752 486 157 62 489 255 241 674 ...\n  .. ..$ ssw : num 51.9\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 470\n $ ssw         : num [1:6] 470 442 400 386 376 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:761] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\n\nccs6 <- clust6$groups\nccs6\n\n  [1] 2 2 1 2 6 1 1 6 2 1 1 4 6 1 4 4 6 2 4 6 1 2 3 2 1 1 4 4 4 1 1 3 2 4 6 1 4\n [38] 4 1 4 2 1 4 4 1 3 3 1 3 1 2 2 2 2 6 1 1 3 1 6 1 6 3 3 2 4 1 6 4 4 4 4 3 3\n [75] 6 6 2 2 2 3 1 3 3 3 3 3 6 6 5 6 3 1 6 3 3 3 3 6 3 6 2 2 3 4 6 3 3 3 3 3 3\n[112] 3 5 3 3 6 6 4 1 2 3 4 3 1 3 3 3 3 3 3 6 1 1 2 2 3 3 6 3 3 3 3 3 5 3 3 3 3\n[149] 3 3 3 3 3 3 1 1 6 5 3 1 6 6 2 3 3 3 2 6 4 4 4 4 4 1 1 4 4 1 2 4 1 2 4 4 4\n[186] 4 2 2 2 4 2 2 2 1 1 1 1 1 1 2 2 2 1 1 1 2 2 1 1 1 6 1 2 2 6 6 3 3 3 3 6 6\n[223] 3 3 3 3 3 3 3 6 3 3 3 6 6 3 4 6 3 3 6 3 2 6 6 3 3 3 6 3 3 1 3 3 6 3 1 3 3\n[260] 3 3 6 6 3 5 3 6 6 4 4 4 4 4 1 4 4 4 1 2 2 6 2 1 4 2 2 2 2 4 4 1 4 4 4 4 4\n[297] 4 4 4 1 3 1 2 2 2 1 2 2 1 1 1 1 4 4 2 1 1 3 2 1 1 4 4 6 2 1 2 2 1 1 6 2 4\n[334] 1 4 4 4 4 3 4 4 4 1 3 2 1 1 4 4 4 4 4 3 4 4 6 6 2 2 2 4 2 4 1 1 2 3 4 2 2\n[371] 4 4 6 3 6 3 3 6 3 3 3 5 3 6 6 6 4 3 3 3 3 3 3 3 4 3 4 3 3 6 6 3 6 3 3 3 3\n[408] 6 1 3 3 3 6 3 3 3 3 3 6 3 1 2 3 3 3 3 3 1 3 1 1 5 6 3 1 3 3 1 3 3 3 3 6 3\n[445] 1 6 6 3 6 1 4 1 1 6 6 6 4 6 4 3 6 4 3 3 5 3 3 3 5 3 6 3 3 1 3 3 6 3 3 3 3\n[482] 3 3 3 3 6 2 2 6 3 6 3 3 2 4 4 5 4 4 6 6 3 1 3 6 3 3 1 1 1 1 1 5 3 2 3 3 2\n[519] 2 6 6 2 2 2 2 2 2 2 6 2 1 6 6 6 2 1 4 2 2 6 6 1 4 4 1 2 4 1 1 2 1 1 4 4 4\n[556] 6 1 2 1 2 2 2 6 6 6 2 1 6 4 4 4 2 1 2 1 6 2 4 1 4 4 4 1 2 4 4 4 6 2 1 2 2\n[593] 1 4 1 4 4 2 4 2 2 2 2 2 2 2 1 1 1 1 2 4 6 1 1 1 1 2 2 2 4 4 2 1 4 4 4 3 6\n[630] 1 4 2 3 6 3 3 3 1 3 3 3 3 6 3 3 3 3 3 3 1 3 4 4 3 3 1 6 1 3 3 6 3 6 6 3 3\n[667] 3 6 1 3 3 3 3 6 1 3 1 3 3 1 4 1 3 2 3 6 3 3 3 3 6 3 3 3 3 1 6 3 3 3 3 2 2\n[704] 1 2 1 1 2 1 2 6 2 2 1 2 2 2 3 2 2 2 6 6 1 2 2 6 3 1 3 3 1 1 1 3 6 3 6 3 3\n[741] 3 4 4 6 6 6 3 3 1 6 6 6 3 3 3 3 3 3 6 3 3\n\n\n\ntable(ccs6)\n\nccs6\n  1   2   3   4   5   6 \n141 128 238 122  11 121 \n\n\n\nplot(nga_wp_sp, border=gray(.5))\nplot(clust6, \n     coordinates(nga_wp_sp), \n     cex.lab=.25,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\n\n\n\n\n\n\n\n\ngroups_mat <- as.matrix(clust6$groups)\nnga_wp_spatialcluster <- cbind(nga_wp_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(nga_wp_spatialcluster, \"SP_CLUSTER\")"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "",
    "text": "For this take-home exercise, we would be exploring the concept of regionalisation with clustering analysis using a multivariate analysis on Nigeria’s waterpoints. With clustering, we hope to be able to uncover multiple variables pairing that might point to a certain phenomena happening at one region of the country."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-clustgeo-method",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-clustgeo-method",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Spatially Constrained Clustering: ClustGeo Method",
    "text": "Spatially Constrained Clustering: ClustGeo Method\n\nClustGeo package\nClustGeo package is customized R package built for tackling the analysis of geospatial clustering. It also has an algorithm or method like ward’s method for hierarchical clustering named hclustgeo().\nTo keep things short, two matrices’ dissimilarity are computed with a confounding variable alpha which can be between [0,1]. The second matrix provides the the dissimilarities in the constraint space while the first matrix can be non-euclidean and provides the dissimilarities in the attribute/clustering variable space. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with the first matrix and the homogeneity criterion calculated with second matrix.\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called choicealpha().\n\n\nWard-like hierarchical clustering: ClustGeo\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n\n\n\n\nNote that the dissimilarity matrix must be an object of class dist, i.e. an object obtained with the function dist().\n\nMapping the clusters formed\n\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n\n\nnga_wp_ngeo_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\n\nqtm(nga_wp_ngeo_cluster, \"CLUSTER\")\n\n\n\n\n\n\n\nSpatially Constrained Hierarchical Clustering\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using st_distance() of sf package.\n\ndist <- st_distance(nga_wp,nga_wp)\ndistmat <- as.dist(dist)\n\nNotice that as.dist() is used to convert the data frame into matrix.\nNext, choicealpha() will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n\n\n\n\n\n\n\nWith reference to the two plots above, we can see the best balance for attribute space versus constraint space is found between 0.3 and 0.4, therefore we will go with 0.35 for alpha\n\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.35)\n\nNext, cutree() is used to derive the cluster objecct.\n\ngroups <- as.factor(cutree(clustG, k=6))\n\nWe will then join back the group list with nga_wp (Nigerian waterpoint) polygon feature data frame by using the code chunk below.\n\nnga_wp_Gcluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\n\nqtm(nga_wp_Gcluster, \"CLUSTER\")"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#visual-interpretation-of-clusters",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#visual-interpretation-of-clusters",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Visual Interpretation of Clusters",
    "text": "Visual Interpretation of Clusters\n\nVisualising individual clustering variable\n\nggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_functional)) +\n  geom_boxplot()\n\n\n\n\nThe boxplot reveals that cluster 6 has the highest percentage of functional water points while cluster 1 seems to have the largest distribution. We then visualise all 8 variables together\n\npf <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_functional))+\n  geom_boxplot() +\n  ggtitle(\"functional waterpoints(%)\")\n\npn <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_nonfunctional))+\n  geom_boxplot() +\n  ggtitle(\"non-functional waterpoints(%)\")\n\n\nph <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_handpump))+\n  geom_boxplot() +\n  ggtitle(\"handpump waterpoints(%)\")\n\npr <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_rural))+\n  geom_boxplot() +\n  ggtitle(\"rural waterpoints(%)\")\n\npu <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_usage1000))+\n  geom_boxplot() +\n  ggtitle(\"waterpoints(%)limit 1000\")\n\npb <- ggplot(data = nga_wp_ngeo_cluster,\n       aes(x = CLUSTER, y = pct_usage_below_1000))+\n  geom_boxplot() +\n  ggtitle(\"waterpoints(%)limit < 1000\")\n\nggarrange(pf, pn,ph,pr,pu,pb,\n          ncol =2,\n          nrow = 3)\n\n\n\n\nFrom the box plot above, we can describe cluter 6 as the cluster with mainly handpump and mostly rural with most water point limit below 1000 and they have the more areas with higher percentages of functional water point.\nIn contrast, we can see that cluster 2 has more areas with relatively higher percentage of non-functional water points, it also has one of the lowest distributions for percentage of handpumps which means that likely has more mechanical pumps while it also has high amount of area with high percentage of waterpoints with usage limit at 1000. The higher water limit coupled with most water point being mechanical water points could have contributed to more non-functional water points and the clustering has helped to bring up this potential correlation.\n\n\nMultivariate Visualisation\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\nggarrange(\nggparcoord(data = nga_wp_ngeo_cluster[nga_wp_ngeo_cluster$CLUSTER %in% c(1,2,3),], \n           columns = c(13:18), \n           scale = \"globalminmax\",\n           alphaLines = 0.1,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of LGA waterpoint Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30,size = 5)),\nggparcoord(data = nga_wp_ngeo_cluster[nga_wp_ngeo_cluster$CLUSTER %in% c(4,5,6),], \n           columns = c(13:18), \n           scale = \"globalminmax\",\n           alphaLines = 0.1,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of LGA waterpoint Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30,size = 5)),\n  ncol = 1,\n  nrow = 2\n)\n\n\n\n\nFor this plot, we use the uniminmax to ensure every variable is scaled to [0,1]. WE can see that from this, cluster 1 on top left is least rural, and in general areas in the cluster have relatively low percentage of handpump waterpoints. with some outliers and the cluster has a mean of 50% functional waterpoints with the largest distribution for this value. The same observation applies as described in the observations above where cluster 6 in bottom right can be seen with the highest percentage of functional waterpoints, handpump water points and usage limit below 1000. Next, we take a look at the mean for each cluster:\n\nnga_wp_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_functional = mean(pct_functional),\n            mean_nonfunctional = mean(pct_nonfunctional),\n            mean_handpump = mean(pct_handpump),\n            mean_rural = mean(pct_rural),\n            mean_usage1000 = mean(pct_usage1000),\n            mean_usage_below_1000 = mean(pct_usage_below_1000))\n\n# A tibble: 6 × 7\n  CLUSTER mean_functional mean_nonfunctional mean_hand…¹ mean_…² mean_…³ mean_…⁴\n  <chr>             <dbl>              <dbl>       <dbl>   <dbl>   <dbl>   <dbl>\n1 1                 0.533              0.224      0.204   0.0786   0.512   0.179\n2 2                 0.438              0.528      0.210   0.877    0.745   0.255\n3 3                 0.383              0.445      0.595   0.878    0.231   0.769\n4 4                 0.223              0.251      0.0578  0.671    0.413   0.587\n5 5                 0.491              0.395      0.542   0.231    0.340   0.660\n6 6                 0.728              0.252      0.839   0.899    0.138   0.862\n# … with abbreviated variable names ¹​mean_handpump, ²​mean_rural,\n#   ³​mean_usage1000, ⁴​mean_usage_below_1000\n\n\nLooking at the mean for each value in the clusters, we can safely say that they support the observations made above where mean of cluster 6 are high for rural, usage below 1000, handpump water points and functional percentage. While cluster 1 is the least rural with lowest amount of handpump. Another possible correlation to look at count be that the lower the percentage the handpump, the more likely that the percentage of functional waterpoints is lower."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section-2",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section-2",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "",
    "text": "Conclusion\nBased on what has been observed, we could quite safely say that spatially constrained clustering appears to be much better for working on the challenge and analysis of geospatial clusters. We can see that without the spatial constraints, the clusters appear more fragmented and might not be able to achieve the objective of allowing the analyst working on the project to draw the right insights. Below, we can take a final look between a SKATER clustered map and a hierarchical clustered map.\n\ngroups_mat <- as.matrix(clust6$groups)\nnga_wp_spatialcluster <- cbind(nga_wp_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nnga_wp_spatialcluster_map <- qtm(nga_wp_spatialcluster, \"SP_CLUSTER\", title = \"SKATER clustering\")\n\nnga_wp_cluster_map <- qtm(nga_wp_cluster,\n                   \"CLUSTER\", title = \"Hierarchical clustering\") \n\ntmap_arrange(nga_wp_spatialcluster_map, nga_wp_cluster_map,\n             asp=NA, ncol=2)\n\n\n\n\n\nCredits\nAs usual, most credits goes to Prof Kam for his well structured in class exercise we can use to reference off for the exercise. Also many credits to our exemplary classmate Jordan for having such a well structured code for the rest of the class to refer to."
  }
]