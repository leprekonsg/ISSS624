[
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#getting-started",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#getting-started",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nAs usual, to get started, we will load the necessary R packages. For the purpose of this in-class exercise, three R packages will be used, they are:\n\nsf for importing and processing geospatial data,\ntidyverse for importing and processing non-spatial data. In this exercise, readr package will be used for importing wkt data and dplyr package will be used to wrangling the data.\n\n\npacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally,funModeling)\n\n\n#command above make sure quarto does not execute\nwp <- st_read(dsn = \"geodata\",\n        layer = \"geo_export\",\n        crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\n\nwp_sf <- st_sf(wp, crs=4326) \n\n\nnga <- st_read(dsn = \"geodata\",\n              layer = \"geoboundaries-NGA-ADM2\")"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#data-wrangling",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#data-wrangling",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nHandling Duplicates\nBelow codes are referenced from our exemplary classmate Jordan (link), recommended by prof Kam.\n\nnigeria <- (nga[order(nga$shapeName), ])\n\nduplicate_area <- nigeria$shapeName[ nigeria$shapeName %in% nigeria$shapeName[duplicated(nigeria$shapeName)] ]\n\nduplicate_area\n\n\ntmap_mode(\"view\")\n\ntm_shape(nigeria[nigeria$shapeName %in% duplicate_area,]) +\n  tm_view(set.zoom.limits = c(5,9))+\n  tm_polygons()\n\n\nnigeria$shapeName[c(94,95,304,305,355,356,519,546,547,693,694)] <- c(\"Bassa (Kogi)\",\"Bassa (Plateau)\",\n                                                                               \"Ifelodun (Kwara)\",\"Ifelodun (Osun)\",\n                                                                               \"Irepodun (Kwara)\",\"Irepodun (Osun)\",\n                                                                               \"Nassarawa\",\"Obi (Benue)\",\"Obi(Nasarawa)\",\n                                                                               \"Surulere (Lagos)\",\"Surulere (Oyo)\")\n\nlength((nigeria$shapeName[ nigeria$shapeName %in% nigeria$shapeName[duplicated(nigeria$shapeName)] ]))\n\nHere we replaced NA values with “Unknown” to help facilitate processing\n\nwp_sf <- st_join(wp_sf, nigeria)  %>%\n  mutate(status_cle=replace_na(status_cle,\"Unknown\"))"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#exploratory-data-analysis",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#exploratory-data-analysis",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Exploratory Data Analysis",
    "text": "Exploratory Data Analysis\n\nfreq(data=wp_sf,\n     input = 'status_cle')"
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#section",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "",
    "text": "wpt_functional <- wp_sf %>%\n  filter(status_cle %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\nwpt_nonfunctional <- wp_sf %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\n\nfreq(data=wp_sf, \n     input = 'water_te_2')\n\nAs there are some Hand Pumps that are labelled slightly differently, we have to use str_detect from stringr library to do a wildcard detection where we filter for anything that contains “Hand Pump”\n\nwpt_handpump <- wp_sf %>%\n  filter(str_detect(water_te_2, \"Hand Pump\"))\n\n\nfreq(data=wpt_handpump, \n     input = 'water_te_2')\n\n\nfreq(data=wp_sf, \n     input = 'usage_cap')\n\n\nwpt_usage_abv_1000 <- wp_sf %>%\n  filter(`usage_cap` >= 1000)\n\n\nwpt_usage_less_1000 <- wp_sf %>%\n  filter(`usage_cap` < 1000)\n\n\nfreq(data=wpt_usage_less_1000, \n     input = 'usage_cap')\n\n\nfreq(data=wp_sf, \n     input = 'is_urban')\n\n\nwpt_rural <- wp_sf %>%\n  filter(`is_urban` == \"False\")\n\n\nfreq(data=wpt_rural, \n     input = 'is_urban')\n\n\nnga_wp <- nigeria %>% \n  mutate(`total wpt` = lengths(\n    st_intersects( nigeria,wp_sf))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nigeria, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nigeria, wpt_nonfunctional))) %>%\n  mutate(`wpt_handpump` = lengths(\n    st_intersects(nigeria, wpt_handpump))) %>%\n  mutate(`wpt usage_cap 1000` = lengths(\n    st_intersects(nigeria, wpt_usage_abv_1000))) %>%\n  mutate(`wpt usage_cap below 1000` = lengths(\n    st_intersects(nigeria, wpt_usage_less_1000))) %>%\n  mutate(`wpt rural` = lengths(\n    st_intersects(nigeria, wpt_rural)))\n\n\nwrite_rds(nga_wp, \"geodata/nga_wp.rds\")\n\n\nnga_wp <- read_rds(\"geodata/nga_wp.rds\")\nnga_wp <- nga_wp %>%\n  filter(`total wpt` > 0) %>%\n  mutate(`wpt non-functional` = replace_na(`wpt non-functional`, 0)) %>%\n  mutate(`wpt functional` = replace_na(`wpt functional`, 0))\n\n\n\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nnga_wp <- st_transform(nga_wp, \n                              crs = 26391)\ntotal <- tm_shape(nga_wp) +\n  tm_fill(\"total wpt\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"total\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nwp_functional <- tm_shape(nga_wp) +\n  tm_fill(\"wpt functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nwp_nonfunctional <- tm_shape(nga_wp) +\n  tm_fill(\"wpt non-functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"non-functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nhandpump <- tm_shape(nga_wp) +\n  tm_fill(\"wpt_handpump\",\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"handpump\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nusageabv <- tm_shape(nga_wp) +\n  tm_fill(\"wpt usage_cap 1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"usage cap 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nusagebelow <- tm_shape(nga_wp) +\n  tm_fill(\"wpt usage_cap below 1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"usage cap < 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\nrural <- tm_shape(nga_wp) +\n  tm_fill(\"wpt rural\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"rural waterpoints\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\n\ntmap_arrange(total, wp_functional, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(wp_nonfunctional, handpump, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(usageabv,usagebelow, asp=1, ncol=2)\n\n\n\n\nWe can see from below if total water points and rural water points are used for comparison, they look about the same, therefore it could be better to look at the percentage\n\ntmap_arrange(total,rural,asp=1, ncol=2)\n\n\n\n\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = case_when(\n    `wpt functional` == 0 ~ 0,\n    TRUE ~ `wpt functional`/`total wpt`\n    )) %>%\n  mutate(pct_nonfunctional = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt non-functional`/`total wpt`\n    )) %>%\n  mutate(pct_handpump = case_when(\n    `wpt_handpump` == 0 ~ 0,\n    TRUE ~ `wpt_handpump`/`total wpt`\n    )) %>%\n  mutate(pct_rural = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt rural`/`total wpt`\n    )) %>%\n  mutate(pct_usage1000 = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt usage_cap 1000`/`total wpt`\n    )) %>%\n  mutate(pct_usage_below_1000 = case_when(\n    `wpt non-functional` == 0 ~ 0,\n    TRUE ~ `wpt usage_cap below 1000`/`total wpt`\n    )) \n\n\npct_functional <- tm_shape(nga_wp) +\n  tm_fill(\"pct_functional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_nonfunctional <- tm_shape(nga_wp) +\n  tm_fill(\"pct_nonfunctional\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"non-functional\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_handpump <- tm_shape(nga_wp) +\n  tm_fill(\"pct_handpump\",\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of handpumps\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_usageabv <- tm_shape(nga_wp) +\n  tm_fill(\"pct_usage1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoints usage = 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_usagebelow <- tm_shape(nga_wp) +\n  tm_fill(\"pct_usage_below_1000\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoints usage below 1000\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\npct_rural <- tm_shape(nga_wp) +\n  tm_fill(\"pct_rural\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Percentage of waterpoint that are rural\",legend.height = 0.25, main.title.size = 0.8,\n            legend.width = 0.35)\n\ntmap_arrange(pct_functional, pct_nonfunctional, pct_handpump,pct_usageabv,pct_usagebelow, pct_rural, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(pct_functional, pct_nonfunctional, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(pct_usageabv,pct_usagebelow, asp=1, ncol=2)\n\n\n\n\nPercentage for rural water points and total paints a different picture compared to the absolute number of rural water points seen above\n\ntmap_arrange(total, pct_rural, asp=1, ncol=2)\n\n\n\n\n\nSummary Statistics\n\nsummary(nga_wp)\n\n  shapeName            Level             shapeID           shapeGroup       \n Length:761         Length:761         Length:761         Length:761        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n  shapeType                  geometry     total wpt     wpt functional  \n Length:761         MULTIPOLYGON :761   Min.   :  1.0   Min.   :  0.00  \n Class :character   epsg:26391   :  0   1st Qu.: 48.0   1st Qu.: 18.00  \n Mode  :character   +proj=tmer...:  0   Median : 97.0   Median : 47.00  \n                                        Mean   :124.8   Mean   : 68.51  \n                                        3rd Qu.:170.0   3rd Qu.: 88.00  \n                                        Max.   :894.0   Max.   :752.00  \n wpt non-functional  wpt_handpump    wpt usage_cap 1000\n Min.   :  0.00     Min.   :  0.00   Min.   :  0.00    \n 1st Qu.: 14.00     1st Qu.:  7.00   1st Qu.: 12.00    \n Median : 34.00     Median : 48.00   Median : 26.00    \n Mean   : 42.31     Mean   : 77.18   Mean   : 33.69    \n 3rd Qu.: 61.00     3rd Qu.:112.00   3rd Qu.: 46.00    \n Max.   :278.00     Max.   :764.00   Max.   :245.00    \n wpt usage_cap below 1000   wpt rural      pct_functional   pct_nonfunctional\n Min.   :  0.00           Min.   :  0.00   Min.   :0.0000   Min.   :0.0000   \n 1st Qu.: 18.00           1st Qu.: 25.00   1st Qu.:0.3333   1st Qu.:0.2211   \n Median : 61.00           Median : 65.00   Median :0.4792   Median :0.3559   \n Mean   : 91.12           Mean   : 99.11   Mean   :0.5070   Mean   :0.3654   \n 3rd Qu.:129.00           3rd Qu.:143.00   3rd Qu.:0.6749   3rd Qu.:0.5082   \n Max.   :767.00           Max.   :894.00   Max.   :1.0000   Max.   :1.0000   \n  pct_handpump      pct_rural      pct_usage1000    pct_usage_below_1000\n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000      \n 1st Qu.:0.1860   1st Qu.:0.5702   1st Qu.:0.1197   1st Qu.:0.3814      \n Median :0.5255   Median :0.8642   Median :0.3060   Median :0.6630      \n Mean   :0.4956   Mean   :0.7224   Mean   :0.3683   Mean   :0.5989      \n 3rd Qu.:0.7857   3rd Qu.:1.0000   3rd Qu.:0.5667   3rd Qu.:0.8676      \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000      \n\n\n\nfunc <- ggplot(data=nga_wp, \n             aes(x= `wpt functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nnonfunc <- ggplot(data=nga_wp, \n             aes(x= `wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nggarrange(func , nonfunc,\n          ncol = 2, \n          nrow = 1)\n\n\n\n\n\nfunc <- ggplot(data=nga_wp, \n             aes(x= `pct_functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nnonfunc <- ggplot(data=nga_wp, \n             aes(x= `pct_nonfunctional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nhandp <- ggplot(data=nga_wp, \n             aes(x= `pct_handpump`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nusagehigh <- ggplot(data=nga_wp, \n             aes(x= `pct_usage1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nusagelow <- ggplot(data=nga_wp, \n             aes(x= `pct_usage_below_1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nrural <- ggplot(data=nga_wp, \n             aes(x= `pct_rural`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\n\nggarrange(func , nonfunc, handp , usagehigh, usagelow, rural, ncol = 3,nrow = 2)\n\n\n\n\n\n\nCorrelation analysis\nSet geometry column to null for correlation analysis\n\nnga_wp$\"wpt functional\" <- as.numeric(nga_wp$\"wpt functional\")\nnga_wp$\"wpt non-functional\" <- as.numeric(nga_wp$\"wpt non-functional\")\nnga_wp_nogeo <- nga_wp %>%\n  st_set_geometry(NULL) %>%\n  select(\"shapeName\", \"wpt non-functional\", \"wpt functional\", \"pct_functional\",\"pct_nonfunctional\", \"pct_handpump\", \"pct_usage_below_1000\",\"pct_usage1000\", \"pct_rural\")\nhead(nga_wp_nogeo,10)\n\n        shapeName wpt non-functional wpt functional pct_functional\n1       Aba North                  9              7      0.4117647\n2       Aba South                 35             29      0.4084507\n3           Abaji                 34             23      0.4035088\n4            Abak                 25             23      0.4791667\n5       Abakaliki                 42             82      0.3519313\n6  Abeokuta North                 15             16      0.4705882\n7  Abeokuta South                 33             72      0.6050420\n8             Abi                 62             79      0.5197368\n9     Aboh-Mbaise                 26             18      0.2727273\n10     Abua/Odual                 13             25      0.6410256\n   pct_nonfunctional pct_handpump pct_usage_below_1000 pct_usage1000  pct_rural\n1          0.5294118   0.11764706           0.17647059     0.8235294 0.00000000\n2          0.4929577   0.09859155           0.12676056     0.8732394 0.05633803\n3          0.5964912   0.40350877           0.40350877     0.5964912 0.84210526\n4          0.5208333   0.08333333           0.08333333     0.9166667 0.83333333\n5          0.1802575   0.43776824           0.90557940     0.0944206 0.87553648\n6          0.4411765   0.14705882           0.23529412     0.7647059 0.20588235\n7          0.2773109   0.16806723           0.29411765     0.7058824 0.00000000\n8          0.4078947   0.59868421           0.67105263     0.3289474 0.95394737\n9          0.3939394   0.01515152           0.34848485     0.6515152 0.72727273\n10         0.3333333   0.30769231           0.33333333     0.6666667 0.53846154\n\n\n\ncluster_vars.cor = cor(nga_wp_nogeo[,2:9])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",,number.cex=0.5,\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nWe can see from the correlation plot here that the usage percentage above 1000 and below 1000 are highly correlated, that is probably because if the usage is not >=1000, then it will belong in the other category. This likely means that only one should be used for cluster analysis, in this case we will be dropping percentage of water point with usage >=1000 and using the one that is below 1000."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#hierarchy-cluster-analysis",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#hierarchy-cluster-analysis",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Hierarchy Cluster Analysis",
    "text": "Hierarchy Cluster Analysis\n\nExtracting clustering variables\n\ncluster_vars <- nga_wp_nogeo %>%\n  select(\"shapeName\", \"wpt non-functional\", \"wpt functional\", \"pct_functional\",\"pct_nonfunctional\", \"pct_handpump\", \"pct_usage_below_1000\", \"pct_rural\")\nhead(cluster_vars,10)\n\n        shapeName wpt non-functional wpt functional pct_functional\n1       Aba North                  9              7      0.4117647\n2       Aba South                 35             29      0.4084507\n3           Abaji                 34             23      0.4035088\n4            Abak                 25             23      0.4791667\n5       Abakaliki                 42             82      0.3519313\n6  Abeokuta North                 15             16      0.4705882\n7  Abeokuta South                 33             72      0.6050420\n8             Abi                 62             79      0.5197368\n9     Aboh-Mbaise                 26             18      0.2727273\n10     Abua/Odual                 13             25      0.6410256\n   pct_nonfunctional pct_handpump pct_usage_below_1000  pct_rural\n1          0.5294118   0.11764706           0.17647059 0.00000000\n2          0.4929577   0.09859155           0.12676056 0.05633803\n3          0.5964912   0.40350877           0.40350877 0.84210526\n4          0.5208333   0.08333333           0.08333333 0.83333333\n5          0.1802575   0.43776824           0.90557940 0.87553648\n6          0.4411765   0.14705882           0.23529412 0.20588235\n7          0.2773109   0.16806723           0.29411765 0.00000000\n8          0.4078947   0.59868421           0.67105263 0.95394737\n9          0.3939394   0.01515152           0.34848485 0.72727273\n10         0.3333333   0.30769231           0.33333333 0.53846154\n\n\nIn the code below, we first change the row name to be same as “shapeName” which is the area name and then we remove the column\n\nrow.names(cluster_vars) <- cluster_vars$\"shapeName\"\nnga_wp_analysis <- select(cluster_vars, c(2:8))\nhead(nga_wp_analysis, 10)\n\n               wpt non-functional wpt functional pct_functional\nAba North                       9              7      0.4117647\nAba South                      35             29      0.4084507\nAbaji                          34             23      0.4035088\nAbak                           25             23      0.4791667\nAbakaliki                      42             82      0.3519313\nAbeokuta North                 15             16      0.4705882\nAbeokuta South                 33             72      0.6050420\nAbi                            62             79      0.5197368\nAboh-Mbaise                    26             18      0.2727273\nAbua/Odual                     13             25      0.6410256\n               pct_nonfunctional pct_handpump pct_usage_below_1000  pct_rural\nAba North              0.5294118   0.11764706           0.17647059 0.00000000\nAba South              0.4929577   0.09859155           0.12676056 0.05633803\nAbaji                  0.5964912   0.40350877           0.40350877 0.84210526\nAbak                   0.5208333   0.08333333           0.08333333 0.83333333\nAbakaliki              0.1802575   0.43776824           0.90557940 0.87553648\nAbeokuta North         0.4411765   0.14705882           0.23529412 0.20588235\nAbeokuta South         0.2773109   0.16806723           0.29411765 0.00000000\nAbi                    0.4078947   0.59868421           0.67105263 0.95394737\nAboh-Mbaise            0.3939394   0.01515152           0.34848485 0.72727273\nAbua/Odual             0.3333333   0.30769231           0.33333333 0.53846154\n\n\n\n\nData Standardisation\nSince, we can see from above, the number of functional and non-functional water points are not standardised, we would need to perform data standardisation for these 2 columns. They are also not normally distributed so we will be performing min-max standardisation here as we want our data to be still in the same scale as those in percentage.\n\nnga_wp_analysis.std <- nga_wp_analysis %>%\n  normalize(nga_wp_analysis[,1:2])\n#left_join(nga_wp_analysis.std,nga_wp_analysis[,3:7], by = \"row\")\nsummary(nga_wp_analysis.std)\n\n wpt non-functional wpt functional    pct_functional   pct_nonfunctional\n Min.   :0.00000    Min.   :0.00000   Min.   :0.0000   Min.   :0.0000   \n 1st Qu.:0.05036    1st Qu.:0.02394   1st Qu.:0.3333   1st Qu.:0.2211   \n Median :0.12230    Median :0.06250   Median :0.4792   Median :0.3559   \n Mean   :0.15218    Mean   :0.09110   Mean   :0.5070   Mean   :0.3654   \n 3rd Qu.:0.21942    3rd Qu.:0.11702   3rd Qu.:0.6749   3rd Qu.:0.5082   \n Max.   :1.00000    Max.   :1.00000   Max.   :1.0000   Max.   :1.0000   \n  pct_handpump    pct_usage_below_1000   pct_rural     \n Min.   :0.0000   Min.   :0.0000       Min.   :0.0000  \n 1st Qu.:0.1860   1st Qu.:0.3814       1st Qu.:0.5702  \n Median :0.5255   Median :0.6630       Median :0.8642  \n Mean   :0.4956   Mean   :0.5989       Mean   :0.7224  \n 3rd Qu.:0.7857   3rd Qu.:0.8676       3rd Qu.:1.0000  \n Max.   :1.0000   Max.   :1.0000       Max.   :1.0000  \n\n\n\n\nVisualising the standardised clustering variables\nWe can see from the distribution below for the right plot that the non-functional water points field has been normalised to values between 0 and 1(without change in distribution) instead of the non-standardised values in the plot on the left.\n\nr <- ggplot(data=nga_wp_analysis, \n             aes(x= `wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nanalysis_df <- as.data.frame(nga_wp_analysis.std)\ns <- ggplot(data=analysis_df, \n       aes(x=`wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nggarrange(r, s,\n          ncol =2,\n          nrow = 1)\n\n\n\n\n\n\nComputing proximity matrix\nConsidering we are measuring geometric distance and based on grids, euclidean distance is chosen as the method.\n\nproxmat <- dist(nga_wp_analysis.std, method = 'euclidean')\n\n\n\nComputing hierarchical clustering\n\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\n\nplot(hclust_ward, cex = 0.6)\n\n\n\n\n\n\nSelecting the optimal clustering algorithm\nFor hierarchical clustering, there are various ways to sequence the clustering. Due to that, it can sometimes be hard to pick which is the better option for the given dataset. Therefore in order to pick out the most suitable clustering technique, we use the agnes() function of cluster package. This function will help pick out the best clustering structure based on the agglomerative coefficent where 1 would be the best score.\n\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(nga_wp_analysis.std, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n  average    single  complete      ward \n0.9054253 0.7677768 0.9415830 0.9910247 \n\n\nAs we see above, ward’s method presents the best clustering structure with a score of 0.99. Therefore, we would proceed with ward’s method for subsequent analysis.\n\n\nDetermining Optimal Clusters\nDetermining the number of optimal cluster is also another difficult challenge in the realm of clustering. For this, we’ll be using the gap statistic method, which is sort of similar to elbow method for choosing the optimal number of clusters. To compute the gap statistic, clusGap() of cluster package will be used. We specify max number of clusters to be 10, and number of monte carlo sampling to be 500 as recommended by the documentation.\n\nset.seed(12345)\ngap_stat <- clusGap(nga_wp_analysis.std, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 500)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = nga_wp_analysis.std, FUNcluster = hcut, K.max = 10, B = 500, nstart = 25)\nB=500 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 10\n          logW   E.logW       gap      SE.sim\n [1,] 5.096626 5.638929 0.5423031 0.007110390\n [2,] 4.873943 5.534293 0.6603497 0.009545438\n [3,] 4.756242 5.481609 0.7253662 0.008869419\n [4,] 4.666234 5.437195 0.7709611 0.009345141\n [5,] 4.612874 5.404208 0.7913343 0.008704832\n [6,] 4.559968 5.376020 0.8160519 0.008668227\n [7,] 4.521663 5.351141 0.8294784 0.008701038\n [8,] 4.495129 5.329140 0.8340112 0.008588832\n [9,] 4.456500 5.309351 0.8528514 0.008341663\n[10,] 4.425849 5.291402 0.8655533 0.008149886\n\n\n\nfviz_gap_stat(gap_stat)\n\n\n\n\n\nprint(gap_stat, method = \"globalSEmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = nga_wp_analysis.std, FUNcluster = hcut, K.max = 10, B = 500, nstart = 25)\nB=500 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'globalSEmax', SE.factor=1): 10\n          logW   E.logW       gap      SE.sim\n [1,] 5.096626 5.638929 0.5423031 0.007110390\n [2,] 4.873943 5.534293 0.6603497 0.009545438\n [3,] 4.756242 5.481609 0.7253662 0.008869419\n [4,] 4.666234 5.437195 0.7709611 0.009345141\n [5,] 4.612874 5.404208 0.7913343 0.008704832\n [6,] 4.559968 5.376020 0.8160519 0.008668227\n [7,] 4.521663 5.351141 0.8294784 0.008701038\n [8,] 4.495129 5.329140 0.8340112 0.008588832\n [9,] 4.456500 5.309351 0.8528514 0.008341663\n[10,] 4.425849 5.291402 0.8655533 0.008149886\n\n\nBoth the firstmax and globalSEmax methods agree that the optimal number of clusters is 10, however it seems that the number is still going up and it is not that feasible to have that many clusters so we look at another methodology below:\n\n\nAverage Silhouette Method\nFor the average silthouette method, we can see that 6 cluster is the sweet spot where there is not too little custer and the average silhouette width is maximized and clusters have the least overlap\n\nset.seed(1234)\nfviz_nbclust(nga_wp_analysis.std, kmeans, method = \"silhouette\", k.max = 10) + theme_minimal() + ggtitle(\"Elbow cut method\")\n\n\n\n\n\n\nInterpreting the dendrograms\n\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n\n\n\n\n\n\nVisually-driven hierarchical clustering analysis\n\nTransforming the data frame into a matrix\nThe data was loaded into a data frame, but it has to be a data matrix to make your heatmap.\nThe code chunk below will be used to transform nga_wp_analysis.std(normalized) into a data matrix.\n\nnga_wp_analysis_mat <- data.matrix(nga_wp_analysis.std)\n\n\n\nPlotting interactive cluster heatmap using heatmaply()\nIn the code chunk below, the heatmaply() of heatmaply package is used to build an interactive cluster heatmap.\n\nheatmaply(nga_wp_analysis_mat,\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Nigeria by multi variate waterpoint attributes\",\n          xlab = \"Waterpoint attributes\",\n          ylab = \"Nigerian LGAs\"\n          )\n\n\n\n\n\n\n\n\nMapping the clusters formed\nWith closed examination of the dendragram above, we have decided to retain 6 clusters.\ncutree() of R Base will be used in the code chunk below to derive a 6-cluster model.\n\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\n\nnga_wp_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\n\nqtm(nga_wp_cluster, \"CLUSTER\")\n\n\n\n\nAs demonstrated in the map above, the clustering is rather fragmented and as hierarchical is not natively suited for geospatial clustering."
  },
  {
    "objectID": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-skater-approach",
    "href": "Take-Home_Ex/Take-Home_Ex2/Take-Home_Ex2.html#spatially-constrained-clustering-skater-approach",
    "title": "Take-Home Exercise 2: Regionalisation with Spatially Constrained Cluster Analysis",
    "section": "Spatially Constrained Clustering: SKATER approach",
    "text": "Spatially Constrained Clustering: SKATER approach\n\nConverting into SpatialPolygonsDataFrame\nAs SKATER only allows the use of sp objects(Spatial Polygon Dataframe), we have to convert the original dataframe.\n\nnga_wp_sp <- as_Spatial(nga_wp)\n\n\n\nComputing Neighbour List\n\nnga_wp.nb <- poly2nb(nga_wp_sp)\nsummary(nga_wp.nb)\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n136 497 513 547 with 1 link\n1 most connected region:\n496 with 14 links\n\n\n\nplot(nga_wp_sp, \n     border=grey(.5))\nplot(nga_wp.nb, \n     coordinates(nga_wp_sp), \n     col=\"blue\", \n     add=TRUE)\n\n\n\n\n\n\nComputing minimum spanning tree\n\nCalculating edge costs\nNext, nbcosts() of spdep package is used to compute the cost of each edge. This function compute this distance between each node using the data.frame with observations vector in each node.\n\nlcosts <- nbcosts(nga_wp.nb, nga_wp_analysis.std)\n\n\nnga_wp.w <- nb2listw(nga_wp.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(nga_wp.w)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n136 497 513 547 with 1 link\n1 most connected region:\n496 with 14 links\n\nWeights style: B \nWeights constants summary:\n    n     nn       S0       S1       S2\nB 761 579121 2276.992 3167.591 33929.71\n\n\n\n\n\nComputing minimum spanning tree\nThe minimum spanning tree is computed by mean of the mstree() of spdep package as shown in the code chunk below.\n\nnga_wp.mst <- mstree(nga_wp.w)\n\nCheck if MST is computed and converted to MST class propertly\n\nclass(nga_wp.mst )\n\n[1] \"mst\"    \"matrix\"\n\n\nwe can also see the dimensions of the MST\n\ndim(nga_wp.mst)\n\n[1] 760   3\n\n\n\nhead(nga_wp.mst)\n\n     [,1] [,2]      [,3]\n[1,]  615  614 0.2338982\n[2,]  614  709 0.1913884\n[3,]  709  595 0.2630492\n[4,]  595  197 0.2513327\n[5,]  197  306 0.1603990\n[6,]  197   56 0.2038302\n\n\n\nplot(nga_wp_sp, border=gray(.5))\nplot.mst(nga_wp.mst, \n         coordinates(nga_wp_sp), \n         col=\"blue\", \n         cex.lab=0.3, \n         cex.circles=0.005, \n         add=TRUE)\n\n\n\n\n\n\nComputing spatially constrained clusters using SKATER method\n\nclust6 <- spdep::skater(edges = nga_wp.mst[,1:2], \n                 data = nga_wp_analysis.std, \n                 method = \"euclidean\", \n                 ncuts = 5)\n\n\nstr(clust6)\n\nList of 8\n $ groups      : num [1:761] 2 2 1 2 6 1 1 6 2 1 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:141] 310 311 545 194 559 334 732 14 595 567 ...\n  .. ..$ edge: num [1:140, 1:3] 14 567 81 212 346 531 174 310 545 311 ...\n  .. ..$ ssw : num 76.3\n  ..$ :List of 3\n  .. ..$ node: num [1:128] 33 41 546 574 525 720 369 282 325 370 ...\n  .. ..$ edge: num [1:127, 1:3] 102 18 33 33 370 41 715 546 566 22 ...\n  .. ..$ ssw : num 67\n  ..$ :List of 3\n  .. ..$ node: num [1:238] 49 683 695 229 463 639 660 429 651 679 ...\n  .. ..$ edge: num [1:237, 1:3] 651 639 660 429 679 146 129 735 651 472 ...\n  .. ..$ ssw : num 111\n  ..$ :List of 3\n  .. ..$ node: num [1:122] 585 363 352 451 28 171 70 69 597 537 ...\n  .. ..$ edge: num [1:121, 1:3] 585 270 451 585 272 171 28 16 34 70 ...\n  .. ..$ ssw : num 53.8\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 113 144 265 432 89 469 382 465 158 497 ...\n  .. ..$ edge: num [1:10, 1:3] 265 265 113 432 89 465 158 469 144 382 ...\n  .. ..$ ssw : num 5.48\n  ..$ :List of 3\n  .. ..$ node: num [1:121] 668 408 235 161 711 461 413 131 722 727 ...\n  .. ..$ edge: num [1:120, 1:3] 458 408 752 486 157 62 489 255 241 674 ...\n  .. ..$ ssw : num 51.9\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 470\n $ ssw         : num [1:6] 470 442 400 386 376 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:761] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\n\nccs6 <- clust6$groups\nccs6\n\n  [1] 2 2 1 2 6 1 1 6 2 1 1 4 6 1 4 4 6 2 4 6 1 2 3 2 1 1 4 4 4 1 1 3 2 4 6 1 4\n [38] 4 1 4 2 1 4 4 1 3 3 1 3 1 2 2 2 2 6 1 1 3 1 6 1 6 3 3 2 4 1 6 4 4 4 4 3 3\n [75] 6 6 2 2 2 3 1 3 3 3 3 3 6 6 5 6 3 1 6 3 3 3 3 6 3 6 2 2 3 4 6 3 3 3 3 3 3\n[112] 3 5 3 3 6 6 4 1 2 3 4 3 1 3 3 3 3 3 3 6 1 1 2 2 3 3 6 3 3 3 3 3 5 3 3 3 3\n[149] 3 3 3 3 3 3 1 1 6 5 3 1 6 6 2 3 3 3 2 6 4 4 4 4 4 1 1 4 4 1 2 4 1 2 4 4 4\n[186] 4 2 2 2 4 2 2 2 1 1 1 1 1 1 2 2 2 1 1 1 2 2 1 1 1 6 1 2 2 6 6 3 3 3 3 6 6\n[223] 3 3 3 3 3 3 3 6 3 3 3 6 6 3 4 6 3 3 6 3 2 6 6 3 3 3 6 3 3 1 3 3 6 3 1 3 3\n[260] 3 3 6 6 3 5 3 6 6 4 4 4 4 4 1 4 4 4 1 2 2 6 2 1 4 2 2 2 2 4 4 1 4 4 4 4 4\n[297] 4 4 4 1 3 1 2 2 2 1 2 2 1 1 1 1 4 4 2 1 1 3 2 1 1 4 4 6 2 1 2 2 1 1 6 2 4\n[334] 1 4 4 4 4 3 4 4 4 1 3 2 1 1 4 4 4 4 4 3 4 4 6 6 2 2 2 4 2 4 1 1 2 3 4 2 2\n[371] 4 4 6 3 6 3 3 6 3 3 3 5 3 6 6 6 4 3 3 3 3 3 3 3 4 3 4 3 3 6 6 3 6 3 3 3 3\n[408] 6 1 3 3 3 6 3 3 3 3 3 6 3 1 2 3 3 3 3 3 1 3 1 1 5 6 3 1 3 3 1 3 3 3 3 6 3\n[445] 1 6 6 3 6 1 4 1 1 6 6 6 4 6 4 3 6 4 3 3 5 3 3 3 5 3 6 3 3 1 3 3 6 3 3 3 3\n[482] 3 3 3 3 6 2 2 6 3 6 3 3 2 4 4 5 4 4 6 6 3 1 3 6 3 3 1 1 1 1 1 5 3 2 3 3 2\n[519] 2 6 6 2 2 2 2 2 2 2 6 2 1 6 6 6 2 1 4 2 2 6 6 1 4 4 1 2 4 1 1 2 1 1 4 4 4\n[556] 6 1 2 1 2 2 2 6 6 6 2 1 6 4 4 4 2 1 2 1 6 2 4 1 4 4 4 1 2 4 4 4 6 2 1 2 2\n[593] 1 4 1 4 4 2 4 2 2 2 2 2 2 2 1 1 1 1 2 4 6 1 1 1 1 2 2 2 4 4 2 1 4 4 4 3 6\n[630] 1 4 2 3 6 3 3 3 1 3 3 3 3 6 3 3 3 3 3 3 1 3 4 4 3 3 1 6 1 3 3 6 3 6 6 3 3\n[667] 3 6 1 3 3 3 3 6 1 3 1 3 3 1 4 1 3 2 3 6 3 3 3 3 6 3 3 3 3 1 6 3 3 3 3 2 2\n[704] 1 2 1 1 2 1 2 6 2 2 1 2 2 2 3 2 2 2 6 6 1 2 2 6 3 1 3 3 1 1 1 3 6 3 6 3 3\n[741] 3 4 4 6 6 6 3 3 1 6 6 6 3 3 3 3 3 3 6 3 3\n\n\n\ntable(ccs6)\n\nccs6\n  1   2   3   4   5   6 \n141 128 238 122  11 121 \n\n\n\nplot(nga_wp_sp, border=gray(.5))\nplot(clust6, \n     coordinates(nga_wp_sp), \n     cex.lab=.25,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\n\n\n\n\n\n\n\n\ngroups_mat <- as.matrix(clust6$groups)\nnga_wp_spatialcluster <- cbind(nga_wp_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(nga_wp_spatialcluster, \"SP_CLUSTER\")"
  }
]